\documentclass[12pt]{article}

\usepackage{amsmath}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{geometry}
  \geometry{
    a4paper,
    vmargin={25mm,25mm},
    hmargin={25mm,25mm},
    includehead,
    head={15.5mm}
  }
\renewcommand{\figurename}{Figura}
\renewcommand{\tablename}{Tabela}
\setlength{\parindent}{1.5cm}
\usepackage{indentfirst}
\usepackage[indent=15mm]{parskip}
\pagestyle{fancy}
\fancyhead{}
\fancyhead[r]{\includegraphics[width=25mm]{imagens/DIN_logo.png}}
\fancyhead[C]{\textbf{UNIVERSIDADE ESTADUAL DE MARINGÁ\\CENTRO DE TECNOLOGIA\\DEPARTAMENTO DE INFORMÁTICA}}
\fancyhead[l]{\includegraphics[width=25mm]{imagens/UEM_logo.png}}
\renewcommand{\contentsname}{\centering SUMÁRIO}

\begin{document}

\include{capa}

\tableofcontents
\newpage

\section{Visão Geral do Sistema}
Este relatório detalha a implementação do sistema de gerenciamento de produtos em Assembly 32 bits, com foco nas modificações realizadas para suportar ponto flutuante e syscalls. O sistema utiliza uma lista encadeada simplesmente ligada para armazenar os produtos, implementando operações CRUD, consultas financeiras e geração de relatórios. As principais mudanças incluem o uso de valores monetários em float e a substituição de funções de biblioteca por chamadas de sistema para operações de E/S em arquivos.

A entrega inclui um arquivo makefile para compilar o código-fonte. O makefile utiliza \textit{gcc -m32} para gerar código 32 bits e \textit{-lm} para linkar a biblioteca matemática, portanto é necessário ter instalado o pacote \textit{gcc-multilib} no sistema (em distribuições baseadas no Debian/Ubuntu: \textit{sudo apt install gcc-multilib}). Para compilar o código, execute o comando \textit{make} no terminal. Para rodar o programa, execute \textit{./supermercado}.

\section{Estrutura de Dados Modificada}
A estrutura de dados foi otimizada para suportar valores monetários em ponto flutuante:

\begin{itemize}
    \item \textbf{next}: ponteiro para o próximo nó (4 bytes)
    \item \textbf{tipo}: inteiro (4 bytes)
    \item \textbf{quantidade}: inteiro (4 bytes)
    \item \textbf{valor\_compra}: float (4 bytes) - \textbf{MODIFICADO}
    \item \textbf{valor\_venda}: float (4 bytes) - \textbf{MODIFICADO}
    \item \textbf{nome}: string (50 bytes)
    \item \textbf{lote}: string (20 bytes)
    \item \textbf{dia}: inteiro (4 bytes)
    \item \textbf{mês}: inteiro (4 bytes)
    \item \textbf{ano}: inteiro (4 bytes)
    \item \textbf{fornecedor}: string (50 bytes)
\end{itemize}

\textbf{Offsets dos campos no nó:}
\begin{itemize}
    \item OFFSET\_COMPRA: 12 bytes (campo float)
    \item OFFSET\_VENDA: 16 bytes (campo float)
    \item Demais campos mantiveram seus offsets originais
\end{itemize}

O tamanho total permanece 152 bytes, mas agora com precisão decimal para valores monetários.

\section{Implementação de Ponto Flutuante}

\subsection{Leitura de Valores Float}
A entrada de valores monetários foi modificada para usar scanf com especificador \texttt{\%f}:

\begin{verbatim}
# Leitura do valor de compra (float)
pushl $str_compra_prompt
call  printf
addl  $4, %esp
leal  OFFSET_COMPRA(%ebx), %eax
pushl %eax
pushl $str_float_input      # "%f"
call  scanf
addl  $8, %esp
\end{verbatim}

\subsection{Impressão de Valores Float}
Para impressão, os valores float são convertidos para double na pilha da FPU:

\begin{verbatim}
# Imprime valor de compra (float)
flds  OFFSET_COMPRA(%ebx)   # Carrega float para FPU
subl  $8, %esp              # Espaço para double
fstpl (%esp)                # Converte para double
pushl $fmt_compra           # "Compra: %.2f\n"
call  printf
addl  $12, %esp
\end{verbatim}

\subsection{Operações Aritméticas com FPU}
As funções financeiras foram completamente reescritas para usar a Floating Point Unit:

\textbf{Instruções FPU utilizadas:}
\begin{itemize}
    \item \texttt{fldz}: carrega 0.0 no topo da pilha FPU
    \item \texttt{flds}: carrega float de 32 bits da memória
    \item \texttt{fildl}: carrega inteiro de 32 bits e converte para float
    \item \texttt{faddp}: soma e remove do topo da pilha
    \item \texttt{fmulp}: multiplica e remove do topo da pilha
    \item \texttt{fsubp}: subtrai e remove do topo da pilha
    \item \texttt{fstpl}: armazena como double e remove da pilha
\end{itemize}

\section{Implementação de Syscalls para E/S de Arquivo}

\subsection{Definições de Syscalls}
O código define constantes para syscalls do Linux 32-bit:

\begin{verbatim}
.set SYS_OPEN, 5
.set SYS_CLOSE, 6
.set SYS_READ, 3
.set SYS_WRITE, 4

.set O_RDONLY, 0
.set O_WRONLY, 1
.set O_CREAT, 64
.set O_TRUNC, 512
\end{verbatim}

\subsection{Gravação com Syscalls (save\_list)}
A função foi reescrita para usar syscalls em vez de \texttt{fopen/fwrite/fclose}:

\begin{enumerate}
    \item \textbf{Abertura}: Usa syscall \texttt{open} com flags \texttt{O\_WRONLY | O\_CREAT | O\_TRUNC}
    \item \textbf{Escrita}: Para cada nó, copia 148 bytes (dados sem ponteiro) para buffer e usa syscall \texttt{write}
    \item \textbf{Fechamento}: Usa syscall \texttt{close}
\end{enumerate}

\begin{verbatim}
# Abrir arquivo
movl  $SYS_OPEN, %eax
movl  $filename, %ebx
movl  $(O_WRONLY | O_CREAT | O_TRUNC), %ecx
movl  $0644, %edx           # Permissões
int   $0x80

# Escrever dados
movl  $SYS_WRITE, %eax
# %ebx já tem o file descriptor
movl  $buffer, %ecx
movl  $dados_size, %edx
int   $0x80
\end{verbatim}

\subsection{Leitura com Syscalls (load\_list)}
Processo similar para leitura:

\begin{enumerate}
    \item \textbf{Abertura}: Syscall \texttt{open} com flag \texttt{O\_RDONLY}
    \item \textbf{Leitura}: Loop que lê blocos de 148 bytes com syscall \texttt{read}
    \item \textbf{Processamento}: Para cada bloco lido, aloca nó e insere na lista
    \item \textbf{Término}: Quando \texttt{read} retorna menos que 148 bytes (EOF)
\end{enumerate}

\section{Funções Financeiras com Ponto Flutuante}

\subsection{Função total\_venda}
Implementada de forma similar à \texttt{total\_compra}, mas utilizando o campo \texttt{valor\_venda}:

\begin{verbatim}
total_venda:
    pushl %ebp
    movl  %esp, %ebp
    pushl %ebx
    
    fldz                        # ST(0) = 0.0
    movl  head, %ebx

venda_loop_float:
    testl %ebx, %ebx
    jz    venda_done_float
    
    fildl OFFSET_QUANTIDADE(%ebx)  # Quantidade como float
    flds  OFFSET_VENDA(%ebx)       # Valor de venda (float)
    fmulp %st, %st(1)              # quantidade * valor_venda
    faddp %st, %st(1)              # Acumula total
    
    movl  (%ebx), %ebx             # Próximo nó
    jmp   venda_loop_float

venda_done_float:
    # Resultado em ST(0)
    popl  %ebx
    leave
    ret
\end{verbatim}

\subsection{Função lucro\_total}
Calcula o lucro estimado subtraindo o total de compras do total de vendas:

\begin{verbatim}
lucro_total:
    pushl %ebp
    movl  %esp, %ebp
    
    call  total_compra  # ST(0) = total_compra
    call  total_venda   # ST(0) = total_venda, ST(1) = total_compra
    fsubp %st, %st(1)   # ST(0) = total_venda - total_compra
    
    leave
    ret
\end{verbatim}

A ordem das chamadas é crucial - \texttt{total\_compra} primeiro, depois \texttt{total\_venda}, para que a subtração \texttt{fsubp} resulte em \texttt{venda - compra}.

\subsection{Função capital\_perdido}
Esta função agora implementa a lógica de cálculo de capital perdido com ponto flutuante:

\begin{verbatim}
capital_perdido:
    # ... leitura da data atual ...
    
    movl  head, %ebx
    fldz                    # ST(0) = 0.0 (acumulador)

capital_loop:
    testl %ebx, %ebx
    jz    capital_done
    
    # Carregar data do produto e comparar
    # ... código de comparação de datas ...
    
    cmpl  $-1, %eax         # Se vencido (-1)
    jne   next_capital
    
    # Calcular perda usando FPU
    fildl OFFSET_QUANTIDADE(%ebx)   # Quantidade como float
    flds  OFFSET_COMPRA(%ebx)       # Valor de compra (float)
    fmulp %st, %st(1)               # quantidade * valor_compra
    faddp %st, %st(1)               # Acumula perda total

next_capital:
    movl  (%ebx), %ebx      # Próximo produto
    jmp   capital_loop
\end{verbatim}

\subsection{Função print\_float\_currency}
Nova função para formatação de valores monetários:

\begin{verbatim}
print_float_currency:
    pushl %ebp
    movl  %esp, %ebp
    
    subl  $8, %esp          # Espaço para double
    fstpl (%esp)            # Converte ST(0) para double
    pushl 8(%ebp)           # Formato ("%.2f")
    call  printf
    addl  $12, %esp
    
    leave
    ret
\end{verbatim}

\section{Atualização de Valor de Venda com Float}
A função \texttt{update\_product\_interactive} foi modificada para suportar corretamente a atualização de valores monetários em ponto flutuante:

\begin{verbatim}
update_venda:
    pushl $str_nova_venda           # Prompt para novo valor
    call  printf
    addl  $4, %esp
    
    leal  OFFSET_VENDA(%ebx), %eax  # Usa constante simbólica
    pushl %eax
    pushl $str_float_input          # "%f" - formato correto
    call  scanf                     # Lê valor como float
    addl  $8, %esp
    call  clear_input_buffer
\end{verbatim}

\section{Relatórios e Consultas}
\begin{itemize}
    \item \textbf{Relatório texto}: Agora usa \texttt{fprintf} com \texttt{\%.2f}
    \item \textbf{Funções financeiras}: Todas migradas para FPU
    \item \textbf{Capital perdido}: Corrigido para usar float em vez de centavos
    \item \textbf{Ordenação}: Sem impacto (ordena por campos não monetários)
\end{itemize}
\section{Arquitetura Híbrida: Syscalls + Biblioteca}

O sistema adota uma abordagem híbrida otimizada:

\begin{itemize}
    \item \textbf{Arquivos binários}: Syscalls (maior controle e eficiência).
    \item \textbf{Formatação de texto}: Funções de biblioteca (simplificação).
    \item \textbf{Entrada/saída console}: Funções de biblioteca (compatibilidade).
\end{itemize}

\section{Tratamento de Erros}

\subsection{Verificações Implementadas}
\begin{itemize}
    \item \textbf{Syscalls}: Verificação de retorno negativo indica erro
    \item \textbf{malloc}: Teste de ponteiro nulo antes de uso
    \item \textbf{FPU}: Stack da FPU gerenciada corretamente para evitar overflow
\end{itemize}

\subsection{Limitações Conhecidas}
\begin{itemize}
    \item \textbf{Validação de entrada}: Não há verificação de ranges para valores float
    \item \textbf{Overflow FPU}: Operações com valores muito grandes podem causar exceções
    \item \textbf{Precisão}: Float de 32 bits tem limitações para valores monetários muito grandes
    \item \textbf{Portabilidade}: Syscalls são específicos do Linux 32-bit
\end{itemize}

\section{Conclusão}
As principais modificações incluíram a conversão dos campos monetários de inteiros (centavos) para float e a substituição de funções de biblioteca por syscalls do Linux para operações de E/S em arquivos binários. Todas as funções financeiras foram reescritas para utilizar a Floating Point Unit (FPU) do processador, incluindo \texttt{total\_compra}, \texttt{total\_venda}, \texttt{lucro\_total} e \texttt{capital\_perdido}. A função \texttt{update\_product\_interactive} foi corrigida para aceitar valores float na atualização de preços, e a geração de relatórios foi adaptada para formatar corretamente os valores monetários usando \texttt{fprintf} com especificador \texttt{\%.2f}.

\end{document}